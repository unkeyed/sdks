/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RatelimitRequest = {
  /**
   * The name of this rate limit. This name is used to identify which limit to check during key verification.
   *
   * @remarks
   *
   * Best practices for limit names:
   * - Use descriptive, semantic names like 'api_requests', 'heavy_operations', or 'downloads'
   * - Be consistent with naming conventions across your application
   * - Create separate limits for different resource types or operation costs
   * - Consider using namespaced names for better organization (e.g., 'files.downloads', 'compute.training')
   *
   * You will reference this exact name when verifying keys to check against this specific limit.
   */
  name: string;
  /**
   * The maximum number of operations allowed within the specified time window.
   *
   * @remarks
   *
   * When this limit is reached, verification requests will fail with `code=RATE_LIMITED` until the window resets. The limit should reflect:
   * - Your infrastructure capacity and scaling limitations
   * - Fair usage expectations for your service
   * - Different tier levels for various user types
   * - The relative cost of the operations being limited
   *
   * Higher values allow more frequent access but may impact service performance.
   */
  limit: number;
  /**
   * The duration for each ratelimit window in milliseconds.
   *
   * @remarks
   *
   * This controls how long the rate limit counter accumulates before resetting. Common values include:
   * - 1000 (1 second): For strict per-second limits on high-frequency operations
   * - 60000 (1 minute): For moderate API usage control
   * - 3600000 (1 hour): For less frequent but costly operations
   * - 86400000 (24 hours): For daily quotas
   *
   * Shorter windows provide more frequent resets but may allow large burst usage. Longer windows provide more consistent usage patterns but take longer to reset after limit exhaustion.
   */
  duration: number;
  /**
   * Whether this ratelimit should be automatically applied when verifying a key.
   */
  autoApply?: boolean | undefined;
};

/** @internal */
export const RatelimitRequest$inboundSchema: z.ZodType<
  RatelimitRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  limit: z.number().int(),
  duration: z.number().int(),
  autoApply: z.boolean().default(false),
});

/** @internal */
export type RatelimitRequest$Outbound = {
  name: string;
  limit: number;
  duration: number;
  autoApply: boolean;
};

/** @internal */
export const RatelimitRequest$outboundSchema: z.ZodType<
  RatelimitRequest$Outbound,
  z.ZodTypeDef,
  RatelimitRequest
> = z.object({
  name: z.string(),
  limit: z.number().int(),
  duration: z.number().int(),
  autoApply: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RatelimitRequest$ {
  /** @deprecated use `RatelimitRequest$inboundSchema` instead. */
  export const inboundSchema = RatelimitRequest$inboundSchema;
  /** @deprecated use `RatelimitRequest$outboundSchema` instead. */
  export const outboundSchema = RatelimitRequest$outboundSchema;
  /** @deprecated use `RatelimitRequest$Outbound` instead. */
  export type Outbound = RatelimitRequest$Outbound;
}

export function ratelimitRequestToJSON(
  ratelimitRequest: RatelimitRequest,
): string {
  return JSON.stringify(
    RatelimitRequest$outboundSchema.parse(ratelimitRequest),
  );
}

export function ratelimitRequestFromJSON(
  jsonString: string,
): SafeParseResult<RatelimitRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RatelimitRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RatelimitRequest' from JSON`,
  );
}
