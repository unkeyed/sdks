/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { ratelimitLimit } from "../../funcs/ratelimitLimit.js";
import * as components from "../../models/components/index.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  request: components.V2RatelimitLimitRequestBody$inboundSchema,
};

export const tool$ratelimitLimit: ToolDefinition<typeof args> = {
  name: "ratelimit-limit",
  description: `Apply rate limiting

Check and enforce rate limits for any identifier (user ID, IP address, API client, etc.).

Use this for rate limiting beyond API keys - limit users by ID, IPs by address, or any custom identifier. Supports namespace organization, variable costs, and custom overrides.

**Response Codes**: Rate limit checks return HTTP 200 regardless of whether the limit is exceeded - check the \`success\` field in the response to determine if the request should be allowed. 4xx responses indicate auth, namespace existence/deletion, or validation errors (e.g., 410 Gone for deleted namespaces). 5xx responses indicate server errors.

**Required Permissions**

Your root key must have one of the following permissions:
- \`ratelimit.*.limit\` (to check limits in any namespace)
- \`ratelimit.<namespace_id>.limit\` (to check limits in a specific namespace)

**Side Effects**

Records rate limit metrics for analytics and monitoring, updates rate limit counters with sliding window algorithm, and optionally triggers override matching for custom limits.
`,
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await ratelimitLimit(
      client,
      args.request,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
