/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { ratelimitMultiLimit } from "../../funcs/ratelimitMultiLimit.js";
import * as components from "../../models/components/index.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  request: z.array(components.V2RatelimitLimitRequestBody$inboundSchema),
};

export const tool$ratelimitMultiLimit: ToolDefinition<typeof args> = {
  name: "ratelimit-multi-limit",
  description: `Apply multiple rate limit checks

Check and enforce multiple rate limits in a single request for any identifiers (user IDs, IP addresses, API clients, etc.).

Use this to efficiently check multiple rate limits at once. Each rate limit check is independent and returns its own result with a top-level \`passed\` indicator showing if all checks succeeded.

**Response Codes**: Rate limit checks return HTTP 200 regardless of whether limits are exceeded - check the \`passed\` field to see if all limits passed, or the \`success\` field in each individual result. 4xx responses indicate auth, namespace existence/deletion, or validation errors (e.g., 410 Gone for deleted namespaces). 5xx responses indicate server errors.

**Required Permissions**

Your root key must have one of the following permissions:
- \`ratelimit.*.limit\` (to check limits in any namespace)
- \`ratelimit.<namespace_id>.limit\` (to check limits in all specific namespaces being checked)
`,
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await ratelimitMultiLimit(
      client,
      args.request,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
