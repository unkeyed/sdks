/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { UnkeyCore } from "../core.js";
import { encodeJSON } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { ResponseValidationError } from "../models/errors/responsevalidationerror.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import { UnkeyError } from "../models/errors/unkeyerror.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Reroll Key
 *
 * @remarks
 * Generate a new API key while preserving the configuration from an existing key.
 *
 * This operation creates a fresh key with a new token while maintaining all settings from the original key:
 * - Permissions and roles
 * - Custom metadata
 * - Rate limit configurations
 * - Identity associations
 * - Remaining credits
 * - Recovery settings
 *
 * **Key Generation:**
 * - The system attempts to extract the prefix from the original key
 * - If prefix extraction fails, the default API prefix is used
 * - Key length follows the API's default byte configuration (or 16 bytes if not specified)
 *
 * **Original Key Handling:**
 * - The original key will be revoked after the duration specified in `expiration`
 * - Set `expiration` to 0 to revoke immediately
 * - This allows for graceful key rotation with an overlap period
 *
 * Common use cases include:
 * - Rotating keys for security compliance
 * - Issuing replacement keys for compromised credentials
 * - Creating backup keys with identical permissions
 *
 * **Important:** Analytics and usage metrics are tracked at both the key level AND identity level. If the original key has an identity, the new key will inherit it, allowing you to track usage across both individual keys and the overall identity.
 *
 * **Required Permissions**
 *
 *  Your root key must have:
 *  - `api.*.create_key` or `api.<api_id>.create_key`
 *  - `api.*.encrypt_key` or `api.<api_id>.encrypt_key` (only when the original key is recoverable)
 */
export function keysRerollKey(
  client: UnkeyCore,
  request: components.V2KeysRerollKeyRequestBody,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.V2KeysRerollKeyResponseBody,
    | errors.BadRequestErrorResponse
    | errors.UnauthorizedErrorResponse
    | errors.ForbiddenErrorResponse
    | errors.NotFoundErrorResponse
    | errors.InternalServerErrorResponse
    | UnkeyError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: UnkeyCore,
  request: components.V2KeysRerollKeyRequestBody,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.V2KeysRerollKeyResponseBody,
      | errors.BadRequestErrorResponse
      | errors.UnauthorizedErrorResponse
      | errors.ForbiddenErrorResponse
      | errors.NotFoundErrorResponse
      | errors.InternalServerErrorResponse
      | UnkeyError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      components.V2KeysRerollKeyRequestBody$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload, { explode: true });

  const path = pathToFunc("/v2/keys.rerollKey")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.rootKey);
  const securityInput = secConfig == null ? {} : { rootKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "rerollKey",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.rootKey,
    retryConfig: options?.retries
      || client._options.retryConfig
      || {
        strategy: "backoff",
        backoff: {
          initialInterval: 50,
          maxInterval: 1000,
          exponent: 1.5,
          maxElapsedTime: 10000,
        },
        retryConnectionErrors: true,
      }
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["5XX"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "4XX", "500", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    components.V2KeysRerollKeyResponseBody,
    | errors.BadRequestErrorResponse
    | errors.UnauthorizedErrorResponse
    | errors.ForbiddenErrorResponse
    | errors.NotFoundErrorResponse
    | errors.InternalServerErrorResponse
    | UnkeyError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(200, components.V2KeysRerollKeyResponseBody$inboundSchema),
    M.jsonErr(400, errors.BadRequestErrorResponse$inboundSchema),
    M.jsonErr(401, errors.UnauthorizedErrorResponse$inboundSchema),
    M.jsonErr(403, errors.ForbiddenErrorResponse$inboundSchema),
    M.jsonErr(404, errors.NotFoundErrorResponse$inboundSchema),
    M.jsonErr(500, errors.InternalServerErrorResponse$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, req, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
